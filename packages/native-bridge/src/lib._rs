use core::time::Duration;
use neon::prelude::*;

use std::ffi::OsString;
use std::sync::Condvar;
use std::sync::Mutex;
use std::thread::spawn;

use windows_service::define_windows_service;
use windows_service::service::ServiceControl;
use windows_service::service::ServiceControlAccept;
use windows_service::service::ServiceExitCode;
use windows_service::service::ServiceState;
use windows_service::service::ServiceStatus;
use windows_service::service::ServiceType;
use windows_service::service_control_handler;
use windows_service::service_control_handler::ServiceStatusHandle;
use windows_service::service_control_handler::ServiceControlHandlerResult;
use windows_service::service_dispatcher;

type NodeCallback = fn(state: &str) -> ();

struct GlobalState {
    init: bool,
    node_callback: Option<NodeCallback>,
    status_handle: Option<ServiceStatusHandle>,

    current_state: ServiceState,
    exit_code: u32,
    checkpoint: u32,
    wait_hint: Duration,
}

impl GlobalState {
    const fn new() -> GlobalState {
        GlobalState {
            init: true,
            node_callback: None,
            status_handle: None,

            current_state: ServiceState::Paused,
            exit_code: 0,
            checkpoint: 0,
            wait_hint: Duration::new(30, 0)
        }
    }

    fn goto(&mut self, next_state: ServiceState) -> bool {
        match next_state {
            ServiceState::StartPending => match self.current_state {
                ServiceState::Paused => (),
                _ => return false,
            },

            ServiceState::Running => match self.current_state {
                ServiceState::StartPending => (),
                _ => return false,
            },

            ServiceState::StopPending => match self.current_state {
                ServiceState::Paused => (),
                ServiceState::StartPending => (),
                ServiceState::Running => (),
                _ => return false,
            }

            ServiceState::Stopped => (),
            _ => return false,
        }

        self.current_state = next_state;
        sem.notify_all();
        
        return true;
    }

    fn report(&mut self) -> bool {
        if self.status_handle.is_none() {
            let hr = service_control_handler::register("MainService", |req| {
                react(req)
            });

            if let Ok(h) = hr {
                self.status_handle = Some(h);
            }
        }

        if let Some(h) = self.status_handle {
            let status = ServiceStatus {
                service_type: ServiceType::OWN_PROCESS,
                current_state: self.current_state,
                controls_accepted: ServiceControlAccept::STOP,
                exit_code: ServiceExitCode::Win32(self.exit_code),
                checkpoint: self.checkpoint,
                wait_hint: self.wait_hint,
                process_id: None                
            };

            return h.set_service_status(status).is_ok();
        }

        return false;
    }

    fn notify(&self) {
        if let Some(f) = self.node_callback {
            f("test");
        }        
    }
}

#[allow(non_upper_case_globals)]
static mx: Mutex<GlobalState> = Mutex::new(GlobalState::new());

#[allow(non_upper_case_globals)]
static sem: Condvar = Condvar::new();

define_windows_service!(ffi_service_main, service_main);

fn react(control_event: ServiceControl) -> ServiceControlHandlerResult {
    if control_event == ServiceControl::Interrogate {
        return ServiceControlHandlerResult::NoError;
    }

    if control_event == ServiceControl::Stop {
        if let Ok(ref mut state) = mx.lock() {
            if state.goto(ServiceState::StopPending) {
                state.report();
                state.notify();    
            }
        }

        return ServiceControlHandlerResult::NoError;
    }

    return ServiceControlHandlerResult::NotImplemented;
}

#[neon::main]
fn main(mut cx: ModuleContext) -> NeonResult<()> {
    cx.export_function("create", create)?;
    cx.export_function("finish", finish)?;
    Ok(())
}

fn create(mut cx: FunctionContext) -> JsResult<JsBoolean> {
    if service_gate() {
        return Ok(cx.boolean(false));    
    }

    if service_boot() {
        let r = cx.boolean(true);
        return Ok(r);
    }

    return Ok(cx.boolean(false));
}

fn finish(mut cx: FunctionContext) -> JsResult<JsBoolean> {
    return Ok(cx.boolean(true));
}

fn service_gate() -> bool {
    if let Ok(ref mut state) = mx.lock() {
        if state.init {
            state.init = false;
            return false;
        }
    }

    return true;
}

fn service_boot() -> bool {
    spawn(service_init);

    let mut lock = mx.lock();
    while let Ok(mut guard) = lock {
        let ref mut state = guard;
        match state.current_state {
            ServiceState::StartPending => return true,
            ServiceState::Stopped => return false,
            _ => (),
        }

        lock = sem.wait(guard);
    }

    return false;
}

fn service_init() {
    let hr = service_dispatcher::start("MainService", ffi_service_main);
    if hr.is_err() {
        if let Ok(ref mut state) = mx.lock() {
            state.goto(ServiceState::Stopped);
        }
    }
}

fn service_main(_: Vec<OsString>) {
    let mut lock = mx.lock();
    while let Ok(mut guard) = lock {
        let ref mut state = guard;
        if state.goto(ServiceState::StartPending) {
            state.report();
        }

        if state.current_state == ServiceState::Stopped {
            state.report();
            break;
        }

        lock = sem.wait(guard);
    }
}
